{"version":3,"sources":["vue.js"],"names":["global","factory","exports","module","define","amd","Vue","this","parseText","text","tagRE","test","match","index","value","tokens","lastIndex","exec","push","slice","tag","trim","length","peek","str","charCodeAt","next","eof","len","eatSpace","spaceChr","isStringStart","chr","doubleChr","singleChr","isExpStart","expStartChr","isExpEnd","start","expChrPair","parseString","stringQuote","escapeChr","parseSpecialExp","inExp","startChr","parseExpression","pipeChr","state","startState","filterArgState","filterState","filterNameState","parseDirective","s","dir","expression","replace$1","target","el","parent","parentNode","replaceChild","before$1","insertBefore","extend","to","from","i","def","obj","key","val","enumerable","Object","defineProperty","writable","configurable","isFunction","func","bind","fn","ctx","a","l","arguments","apply","call","Dep","id","uid$1","subs","Observer","dep","Array","isArray","observeArray","walk","observe","vm","ob","addVm","defineReactive","property","getOwnPropertyDescriptor","getter","get","setter","set","childOb","depend","e","__ob__","newVal","notify","on","event","handler","useCapture","addEventListener","off","callback","removeEventListener","compile","nodeLinkFn","compileNode","childLinkFn","hasChildNodes","compileNodeList","childNodes","host","scope","frag","linkAndCapture","linker","originalDirCount","_directives","dirs","_bind","node","type","nodeType","compileElement","compileTextNode","nodeList","linkFns","terminal","nodes","childrenLinkFn","n","linkFn","hasAttrs","hasAttributes","attrs","attributes","checkTerminalDirectives","compileDirectives","attr","name","matched","dirName","rawName","termDef","j","dirAttrRE","publicDirectives","parsed","descriptor","raw","_bindDir","wholeText","token","document","createDocumentFragment","processTextToken","createTextNode","appendChild","fragClone","cloneNode","rawValue","dirDef","arg","parseExpression$1","exp","makeGetterFn","body","Function","Math","Watcher","expOrFn","cb","options","isFn","_watchers","uid$2","active","deps","newDeps","depIds","Set","newDepIds","undefined","res","Directive","_host","_scope","_frag","stringToFragment","templateString","div","createElement","innerHTML","child","firstChild","nodeToFragment","nodeClone","_init","91","123","40","update","html","anchor","replace","swap","remove","parseTemplate","createComment","before","prototype","addSub","sub","removeSub","$remove","addDep","keys","convert","items","vms","createAnchor","uid","vFor","inMatch","itMatch","iterator","alias","end","data","item","empty","create","parentScope","$parent","$forContext","docFrag","template","forId","nextSibling","removeChild","on$1","reset","vBind","setAttribute","for","console","log","has","add","oldValue","removeAttribute","_bound","_update","oldVal","watcher","_watcher","$options","_initData","_initMethods","$mount","methods","dataFn","_data","_proxy","self","_compile","original","querySelector"],"mappings":"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","file":"vue.min.js","sourcesContent":["/*!\n * Vue.js v1.0.28-csp\n * (c) 2018 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Vue = factory());\n}(this, (function () { 'use strict';\n\nvar tagRE = /{{((?:.|\\n)+?)}}/g;\n\n/**\n * 解析文本\n * eg: aaa{{var}}bbb => [{value: 'aaa'}, {value: 'var', tag: true}, {value: 'bbb'}]\n * @param {String} text\n */\n\nfunction parseText(text) {\n  if (!tagRE.test(text)) {\n    return null;\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, value;\n  while (match = tagRE.exec(text)) {\n    index = match.index;\n    value = match[1];\n    if (index > lastIndex) {\n      tokens.push({\n        value: text.slice(lastIndex, index)\n      });\n    }\n\n    tokens.push({\n      tag: true,\n      value: value.trim()\n    });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push({\n      value: text.slice(lastIndex)\n    });\n  }\n  return tokens;\n}\n\nvar str;\nvar dir;\nvar len;\nvar index;\nvar chr;\nvar state;\nvar startState = 0;\nvar filterState = 1;\nvar filterNameState = 2;\nvar filterArgState = 3;\n\nvar doubleChr = 0x22;\nvar singleChr = 0x27;\nvar pipeChr = 0x7C;\nvar escapeChr = 0x5C;\nvar spaceChr = 0x20;\n\nvar expStartChr = { 0x5B: 1, 0x7B: 1, 0x28: 1 };\nvar expChrPair = { 0x5B: 0x5D, 0x7B: 0x7D, 0x28: 0x29 };\n\nfunction peek() {\n  return str.charCodeAt(index + 1);\n}\n\nfunction next() {\n  return str.charCodeAt(++index);\n}\n\nfunction eof() {\n  return index >= len;\n}\n\nfunction eatSpace() {\n  while (peek() === spaceChr) {\n    next();\n  }\n}\n\nfunction isStringStart(chr) {\n  return chr === doubleChr || chr === singleChr;\n}\n\nfunction isExpStart(chr) {\n  return expStartChr[chr];\n}\n\nfunction isExpEnd(start, chr) {\n  return expChrPair[start] === chr;\n}\n\nfunction parseString() {\n  var stringQuote = next();\n  var chr;\n  while (!eof()) {\n    chr = next();\n    // escape char\n    if (chr === escapeChr) {\n      next();\n    } else if (chr === stringQuote) {\n      break;\n    }\n  }\n}\n\nfunction parseSpecialExp(chr) {\n  var inExp = 0;\n  var startChr = chr;\n\n  while (!eof()) {\n    chr = peek();\n    if (isStringStart(chr)) {\n      parseString();\n      continue;\n    }\n\n    if (startChr === chr) {\n      inExp++;\n    }\n    if (isExpEnd(startChr, chr)) {\n      inExp--;\n    }\n\n    next();\n\n    if (inExp === 0) {\n      break;\n    }\n  }\n}\n\n/**\n * syntax:\n * expression | filterName  [arg  arg [| filterName arg arg]]\n */\n\nfunction parseExpression() {\n  var start = index;\n  while (!eof()) {\n    chr = peek();\n    if (isStringStart(chr)) {\n      parseString();\n    } else if (isExpStart(chr)) {\n      parseSpecialExp(chr);\n    } else if (chr === pipeChr) {\n      next();\n      chr = peek();\n      if (chr === pipeChr) {\n        next();\n      } else {\n        if (state === startState || state === filterArgState) {\n          state = filterState;\n        }\n        break;\n      }\n    } else if (chr === spaceChr && (state === filterNameState || state === filterArgState)) {\n      eatSpace();\n      break;\n    } else {\n      if (state === filterState) {\n        state = filterNameState;\n      }\n      next();\n    }\n  }\n\n  return str.slice(start + 1, index) || null;\n}\n\nfunction parseDirective(s) {\n  // reset parser state\n  str = s;\n  dir = {};\n  len = str.length;\n  index = -1;\n  chr = '';\n  state = startState;\n\n  var filters;\n\n  dir.expression = parseExpression().trim();\n\n  return dir;\n}\n\nfunction replace$1(target, el) {\n  var parent = target.parentNode;\n  if (parent) {\n    parent.replaceChild(el, target);\n  }\n}\n\nfunction before$1(el, target) {\n  target.parentNode.insertBefore(el, target);\n}\n\nfunction extend(to, from) {\n  for (var i in from) {\n    to[i] = from[i];\n  }\n}\n\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\nfunction isFunction(func) {\n  return typeof func === 'function';\n}\n\nfunction bind(fn, ctx) {\n  return function (a) {\n    var l = arguments.length;\n    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n  };\n}\n\nvar text = {\n  bind: function bind() {\n    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\n  },\n\n  update: function update(value) {\n    this.el[this.attr] = value;\n  }\n};\n\nvar html = {\n\n  bind: function bind() {\n    // a comment node means this is a binding for\n    // {{{ inline unescaped html }}}\n    if (this.el.nodeType === 8) {\n      // hold nodes\n      this.nodes = [];\n      // replace the placeholder with proper anchor\n      this.anchor = document.createTextNode('v-html');\n      replace(this.el, this.anchor);\n    }\n  },\n\n  update: function update(value) {\n    if (this.nodes) {\n      this.swap(value);\n    } else {\n      this.el.innerHTML = value;\n    }\n  },\n\n  swap: function swap(value) {\n    // remove old nodes\n    var i = this.nodes.length;\n    while (i--) {\n      remove(this.nodes[i]);\n    }\n    // convert new value to a fragment\n    // do not attempt to retrieve from id selector\n    var frag = value ? parseTemplate(value) : document.createComment('');\n    // save a reference to these nodes so we can remove later\n    this.nodes = frag.childNodes;\n    before(frag, this.anchor);\n  }\n};\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * 每个 dep 实例都是一个可观测对象，可被多个指令订阅\n *\n *\n */\nfunction Dep() {\n  this.id = uid$1++;\n  this.subs = [];\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\nDep.prototype.addSub = function (sub) {\n  this.subs.push(sub);\n};\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\nDep.prototype.removeSub = function (sub) {\n  this.subs.$remove(sub);\n};\n\n/**\n * Add self as a dependency to the target watcher.\n */\nDep.prototype.depend = function () {\n  Dep.target.addDep(this);\n};\n\n/**\n * Notify all subscribers of a new value.\n */\nDep.prototype.notify = function () {\n  // stablize the subscriber list first\n  var subs = this.subs;\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nfunction Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n}\n\n// Instance methods\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    this.convert(keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val);\n};\n\n/**\n * Add an owner vm, so that when $set/$delete mutations\n * happen we can notify owner vms to proxy the keys and\n * digest the watchers. This is only called when the object\n * is observed as an instance's root $data.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.addVm = function (vm) {\n  (this.vms || (this.vms = [])).push(vm);\n};\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @param {Vue} [vm]\n * @return {Observer|undefined}\n * @static\n */\n\nfunction observe(value, vm) {\n  if (!value || typeof value !== 'object') {\n    return;\n  }\n  var ob = new Observer(value);\n  if (ob && vm) {\n    ob.addVm(vm);\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nfunction defineReactive(obj, key, val) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          for (var e, i = 0, l = value.length; i < l; i++) {\n            e = value[i];\n            e && e.__ob__ && e.__ob__.dep.depend();\n          }\n        }\n      }\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      if (newVal === value) {\n        return;\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\nvar createAnchor = function createAnchor(anchor) {\n  return document.createComment(anchor);\n};\n\nvar uid = 0;\n\n// 源码里 for 指令写的特别特别复杂\n\nvar vFor = {\n\n  terminal: true,\n\n  bind: function bind() {\n    // support \"item in/of items\" syntax\n    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);\n    if (inMatch) {\n      var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\n      if (itMatch) {\n        this.iterator = itMatch[1].trim();\n        this.alias = itMatch[2].trim();\n      } else {\n        this.alias = inMatch[1].trim();\n      }\n      this.expression = inMatch[2];\n    }\n\n    // uid as a cache identifier\n    this.id = '__v-for__' + ++uid;\n\n    // 添加锚点\n    this.start = createAnchor('v-for-start');\n    this.end = createAnchor('v-for-end');\n\n    replace$1(this.el, this.end);\n    before$1(this.start, this.end);\n\n    // 先不缓存了，简单点\n    // this.cache = Object.create(null)\n  },\n\n  update: function update(data) {\n    var item = data[0];\n    var alias = this.alias;\n    var start = this.start;\n    var end = this.end;\n    // var inDocument = inDoc(start)\n    var i, l, frag, key, value;\n\n    // 每次 update 的时候都先清除下 frag，很粗暴的做法\n    this.empty();\n\n    for (i = 0, l = data.length; i < l; i++) {\n      item = data[i];\n      key = null;\n      value = item;\n      frag = this.create(value, alias, i, key);\n\n      before$1(frag, end);\n    }\n  },\n  /**\n   * Create a new fragment instance.\n   *\n   * @param {*} value\n   * @param {String} alias\n   * @param {Number} index\n   * @param {String} [key]\n   * @return {Fragment}\n   */\n  create: function create(value, alias, index, key) {\n    var host = this._host;\n    // create iteration scope\n    var parentScope = this._scope || this.vm;\n    var scope = Object.create(parentScope);\n    // make sure point $parent to parent scope\n    scope.$parent = parentScope;\n    // for two-way binding on alias\n    scope.$forContext = this;\n    // define scope properties\n    // important: define the scope alias without forced conversion\n    // so that frozen data structures remain non-reactive.\n    defineReactive(scope, alias, value);\n\n    // 创建一个 frag 让他单独和自己的 scope 去 link\n    var docFrag = document.createDocumentFragment();\n    docFrag.appendChild(this.el);\n    var template = docFrag.cloneNode(true).firstChild;\n    var linker = compile(this.el);\n    var unlink = linker(this.vm, template, null, scope);\n    var frag = template;\n\n    frag.forId = this.id;\n\n    return frag;\n  },\n\n  // 清除锚点间的节点\n  empty: function empty() {\n    var start = this.start;\n    var end = this.end;\n    while (start.nextSibling && start.nextSibling !== end) {\n      this.remove(start.nextSibling);\n    }\n  },\n  remove: function remove(node) {\n    if (node && node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  }\n};\n\nfunction on(el, event, handler, useCapture) {\n  el.addEventListener(event, handler, useCapture);\n}\n\nfunction off(el, handler, callback) {\n  el.removeEventListener(handler, callback);\n}\n\nvar on$1 = {\n  bind: function bind() {},\n\n  update: function update(value) {\n    this.handler = value;\n    this.reset();\n\n    on(this.el, this.arg, this.handler);\n  },\n\n  reset: function reset() {\n    off(this.el, this.handler);\n  }\n};\n\nvar vBind = {\n  bind: function bind() {},\n\n  update: function update(value) {\n    this.el.setAttribute(this.arg, value);\n  }\n};\n\nvar publicDirectives = {\n  text: text,\n  html: html,\n  'for': vFor,\n  on: on$1,\n  bind: vBind\n};\n\nvar dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;\n\n/**\n * Compile a template and return a reusable composite link\n * function, which recursively contains more link functions\n * inside. This top level compile function would normally\n * be called on instance root nodes, but can also be used\n * for partial compilation if the partial argument is true.\n *\n * The returned composite link function, when called, will\n * return an unlink function that tearsdown all directives\n * created during the linking phase.\n *\n * 编译一段模板并返回一个可以重复使用的 link 方法，\n * 这个 link 方法（compositeLinkFn）的内部闭包了很多 link 方法，它们都是通过迭代遍历的方式编译而来。\n * 在整个编译过程中最主要的就是指令的编译，当 compositeLinkFn 方法被调用的时候，\n * 每个被闭包的 link 方法会分别被执行生成一个个指令挂载到 vm 实例上（_dirtives属性里）\n * 与此同时指令的 _bind 方法也会被执行，这个 _bind 方法可以理解成“绑定指令”，相当于指令初始化。\n * 每个指令实例的内部都会包含一个 watcher 实例，用来 “watch” 依赖（dep）,\n * 当依赖变动的时候可以通知 watcher 去更新。\n *\n * @param {Element|DocumentFragment} el\n */\nfunction compile(el) {\n  var nodeLinkFn = compileNode(el);\n  var childLinkFn = el.hasChildNodes ? compileNodeList(el.childNodes) : null;\n\n  return function compositeLinkFn(vm, el, host, scope, frag) {\n    // link\n    var dirs = linkAndCapture(function compositeLinkCapturer() {\n      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\n      if (childLinkFn) childLinkFn(vm, el.childNodes, host, scope, frag);\n    }, vm);\n    // :todo\n    return function unlinkFn() {};\n  };\n}\n\n/**\n * Apply a linker to a vm/element pair and capture the\n * directives created during the process.\n *\n * @param {Function} linker\n * @param {Vue} vm\n */\nfunction linkAndCapture(linker, vm) {\n  var originalDirCount = vm._directives.length;\n  linker();\n  // 在有终端指令的情况下会出现多次编译，这个时候需要过滤掉已经初始化过的指令\n  var dirs = vm._directives.slice(originalDirCount);\n  for (var i = 0; i < dirs.length; i++) {\n    dirs[i]._bind();\n  }\n}\n\n/**\n * 编译单个节点\n * @param {Node} node\n * @return {Function|null}\n */\nfunction compileNode(node) {\n  var type = node.nodeType;\n  if (type === 1) {\n    return compileElement(node);\n  } else if (type === 3) {\n    // 其实纯文本节点可以看成一个语法糖\n    // <div>{{foo}}</div> === <div v-text=\"foo\" />\n    return compileTextNode(node);\n  } else {\n    return null;\n  }\n}\n\n/**\n * 编译节点列表\n * @param {NodeList} nodeList\n */\nfunction compileNodeList(nodeList) {\n  var linkFns = [];\n  var nodeLinkFn, childLinkFn, node;\n  for (var i = 0; i < nodeList.length; i++) {\n    node = nodeList[i];\n    nodeLinkFn = compileNode(node);\n    childLinkFn = node.hasChildNodes &&\n    // 如果是终端指令的节点那么内部的子节点都由它自己编译\n    // 因为子节点内的指令有可能依赖于终端指令\n    // 比如 <li v-for=\"item in list\"> <a>{{item}}</a> </li>\n    // a 标签内的 text 指令{{item}}中变量 item 是由 v-for 指令提供的\n    // 所以需要由 v-for 指令自己去编译\n    !(nodeLinkFn && nodeLinkFn.terminal) ? compileNodeList(node.childNodes) : null;\n    // 成对存放\n    linkFns.push(nodeLinkFn, childLinkFn);\n  }\n\n  return function childLinkFn(vm, nodes, host, scope, frag) {\n    var node, nodeLinkFn, childrenLinkFn;\n    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n      node = nodes[n];\n      // 成对取值\n      nodeLinkFn = linkFns[i++];\n      childrenLinkFn = linkFns[i++];\n      var childNodes = node.childNodes;\n      if (nodeLinkFn) {\n        nodeLinkFn(vm, node, host, scope, frag);\n      }\n      if (childrenLinkFn) {\n        childrenLinkFn(vm, childNodes, host, scope, frag);\n      }\n    }\n  };\n}\n\n/**\n * 编译元素\n * @param {Element} el\n */\nfunction compileElement(el) {\n  var linkFn;\n  var hasAttrs = el.hasAttributes();\n  var attrs = hasAttrs && el.attributes;\n  // 检查是否包含终端指令（for 或者 if）\n  if (hasAttrs) {\n    linkFn = checkTerminalDirectives(el, attrs);\n  }\n  // 检查元素指令 eg: <v-if></v-if>\n  // if (!linkFn) {\n  // linkFn = checkElementDirectives(el, options)\n  // }\n  // 检查自定义 component eg: <my-component />\n  // if (!linkFn) {\n  // linkFn = checkComponent(el, options)\n  // }\n  // 常规指令\n  if (!linkFn && hasAttrs) {\n    linkFn = compileDirectives(attrs);\n  }\n  return linkFn;\n}\n\n/**\n * 检查终端指令\n * @param {Element} el\n * @param {Array} attrs\n */\nfunction checkTerminalDirectives(el, attrs) {\n  var attr, name, value, matched, dirName, rawName, def, termDef;\n  for (var i = 0, j = attrs.length; i < j; i++) {\n    attr = attrs[i];\n    name = attr.name;\n    if (matched = name.match(dirAttrRE)) {\n      def = publicDirectives[matched[1]];\n      if (def && def.terminal) {\n        if (!termDef) {\n          termDef = def;\n          rawName = attr.name;\n          value = attr.value;\n          dirName = matched[1];\n        }\n      }\n    }\n  }\n\n  if (termDef) {\n    var parsed = parseDirective(value);\n    var descriptor = {\n      name: dirName,\n      expression: parsed.expression,\n      raw: value,\n      attr: rawName,\n      def: termDef\n    };\n\n    var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\n      vm._bindDir(descriptor, el, host, scope, frag);\n    };\n    fn.terminal = true;\n    return fn;\n  }\n}\n\n/**\n * 编译文本节点\n * @param {Node} node\n */\nfunction compileTextNode(node) {\n  var tokens = parseText(node.wholeText);\n  if (!tokens) {\n    return null;\n  }\n\n  var frag = document.createDocumentFragment();\n  var el, token;\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    el = token.tag ? processTextToken(token) : document.createTextNode(token.value);\n    frag.appendChild(el);\n  }\n\n  return function textNodeLinkFn(vm, el, host, scope) {\n    var fragClone = frag.cloneNode(true);\n    var childNodes = fragClone.childNodes;\n    var token, value, node;\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      token = tokens[i];\n      value = token.value;\n      if (token.tag) {\n        node = childNodes[i];\n        vm._bindDir(token.descriptor, node, host, scope);\n      }\n    }\n    replace$1(el, fragClone);\n  };\n}\n\n/**\n * 编译指令集\n * @param {Array} attrs\n */\nfunction compileDirectives(attrs) {\n  var i = attrs.length;\n  var dirs = [];\n  // arg: 指令参数 eg: 有个指令是 v-on:click 那么 arg 为 click\n  var attr, name, value, rawName, rawValue, dirName, dirDef, matched, arg;\n  while (i--) {\n    attr = attrs[i];\n    name = rawName = attr.name;\n    value = rawValue = attr.value;\n\n    //\n    if (matched = name.match(dirAttrRE)) {\n      dirName = matched[1];\n      arg = matched[2];\n\n      // 应该要在 vm 实例中查找的，因为有可能存在自定义指令的情况\n      // 所以这里的做法是欠妥的\n      dirDef = publicDirectives[dirName];\n      pushDir(dirName, dirDef);\n    }\n  }\n\n  /**\n   * Push a directive.\n   *\n   * @param {String} dirName\n   * @param {Object|Function} def\n   * @param {Array} [interpTokens]\n   */\n\n  function pushDir(dirName, def) {\n    var parsed = parseDirective(value);\n    dirs.push({\n      name: dirName,\n      attr: rawName,\n      raw: rawValue,\n      def: def,\n      expression: parsed && parsed.expression,\n      arg: arg\n    });\n  }\n\n  if (dirs.length) {\n    return function nodeLinkFn(vm, el, host, scope, frag) {\n      var i = dirs.length;\n      while (i--) {\n        vm._bindDir(dirs[i], el, host, scope, frag);\n      }\n    };\n  }\n}\n/**\n * 处理文本 token\n * @param {String} token\n */\nfunction processTextToken(token) {\n  var el = document.createTextNode('');\n  var parsed = parseDirective(token.value);\n  var type = 'text';\n\n  token.descriptor = {\n    name: type,\n    def: publicDirectives[type],\n    expression: parsed.expression\n  };\n\n  return el;\n}\n\nfunction parseExpression$1(exp) {\n  return {\n    get: makeGetterFn('scope.' + exp),\n    set: function set() {}\n  };\n}\n\nfunction makeGetterFn(body) {\n  var fn = new Function('scope', 'Math', 'return ' + body);\n  return function (scope) {\n    return fn.call(this, scope, Math);\n  };\n}\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n *\n * @param {*} vm\n * @param {*} expOrFn\n * @param {*} cb\n * @param {*} options\n */\nfunction Watcher(vm, expOrFn, cb, options) {\n  if (options) {\n    extend(this, options);\n  }\n  var isFn = typeof expOrFn === 'function';\n  this.vm = vm;\n  vm._watchers.push(this);\n  this.expression = expOrFn;\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new Set();\n  this.newDepIds = new Set();\n\n  // parse expression for getter/setter\n  if (isFn) {\n    this.getter = expOrFn;\n    this.setter = undefined;\n  } else {\n    var res = parseExpression$1(expOrFn);\n    this.getter = res.get;\n    this.setter = res.set;\n  }\n  // 这里是 watcher 收集依赖的入口\n  this.value = this.get();\n}\n\nWatcher.prototype.get = function () {\n  Dep.target = this;\n\n  var scope = this.scope || this.vm;\n  var value;\n  try {\n    value = this.getter.call(scope, scope);\n  } catch (e) {\n    console.log(e);\n  }\n  return value;\n};\n\nWatcher.prototype.addDep = function (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\nWatcher.prototype.update = function () {\n  var value = this.get();\n  if (value !== this.value) {\n    // set new value\n    var oldValue = this.value;\n    this.value = value;\n    this.cb.call(this.vm, value, oldValue);\n  }\n};\n\n/**\n * 指令类\n * @param {*} descriptor\n * @param {*} vm\n * @param {*} el\n * @param {*} host\n * @param {*} scope\n * @param {*} frag\n */\nfunction Directive(descriptor, vm, el, host, scope, frag) {\n  this.vm = vm;\n  this.el = el;\n  this.descriptor = descriptor;\n  this.name = descriptor.name;\n  this.expression = descriptor.expression;\n  this.arg = descriptor.arg;\n  // private\n  // this._locked = false\n  // this._bound = false\n  // this._listeners = null\n  // link context\n  this._host = host;\n  this._scope = scope;\n  this._frag = frag;\n}\n\nDirective.prototype._bind = function () {\n  var name = this.name;\n  var descriptor = this.descriptor;\n\n  // 移除属性\n  // 编译过的节点需要移除指令属性防止被再次编译\n  if (this.el && this.el.removeAttribute) {\n    var attr = descriptor.attr || 'v-' + name;\n    this.el.removeAttribute(attr);\n  }\n\n  // 复制 def 属性\n  var def = descriptor.def;\n  if (typeof def === 'function') {\n    this.update = def;\n  } else {\n    extend(this, def);\n  }\n\n  // 初始化 bind\n  if (this.bind) {\n    this.bind();\n  }\n  this._bound = true;\n\n  if (this.expression && this.update) {\n    var dir = this;\n    // 这里套了一层 function 目的是为了让 update 方法内的 this 指向正对的对象\n    this._update = function (val, oldVal) {\n      dir.update(val, oldVal);\n    };\n\n    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\n    {\n      scope: this._scope\n    });\n\n    // if (this.afterBind) {\n    //   this.afterBind()\n    // } else if (this.update) {\n    //   this.update(watcher.value)\n    // }\n    if (this.update) {\n      this.update(watcher.value);\n    }\n  }\n};\n\nfunction stringToFragment(templateString) {\n  var frag = document.createDocumentFragment();\n  var div = document.createElement('div');\n\n  div.innerHTML = templateString;\n\n  var child;\n  while (child = div.firstChild) {\n    frag.appendChild(child);\n  }\n\n  return frag;\n}\n\nfunction nodeToFragment(node) {\n  var nodeClone = node.cloneNode(true);\n  var frag = document.createDocumentFragment();\n\n  var child;\n  while (child = nodeClone.firstChild) {\n    frag.appendChild(child);\n  }\n\n  return frag;\n}\n\nfunction Vue(options) {\n  this._init(options);\n}\n\nVue.prototype._init = function (options) {\n  this.$options = options || {};\n\n  this._directives = [];\n  this._watchers = [];\n\n  this._initData();\n  this._initMethods();\n\n  if (options.el) {\n    // 程序编译的入口\n    this.$mount(options.el);\n  }\n};\n\n/**\n * 初始化 methods\n */\nVue.prototype._initMethods = function () {\n  var methods = this.$options.methods;\n  if (methods) {\n    for (var key in methods) {\n      this[key] = bind(methods[key], this);\n    }\n  }\n};\n\n/**\n * 初始化 data\n */\nVue.prototype._initData = function () {\n  var dataFn = this.$options.data;\n  var data = this._data = dataFn ? isFunction(dataFn) ? dataFn() : dataFn : {};\n  var keys = Object.keys(data);\n  var i, key;\n  i = keys.length;\n  while (i--) {\n    key = keys[i];\n    // 把 data 属性下的 key 代理到 vm 实例上\n    this._proxy(key);\n  }\n  // observable 化 data\n  // 目的为了让 data 在取值/赋值的时候可被监听\n  // 从而实现响应式的效果\n  observe(data, this);\n};\n\nVue.prototype._proxy = function (key) {\n  var self = this;\n  Object.defineProperty(self, key, {\n    configurable: true,\n    enumerable: true,\n    get: function proxyGetter() {\n      return self._data[key];\n    },\n    set: function proxySetter(val) {\n      self._data[key] = val;\n    }\n  });\n};\n\nVue.prototype._bindDir = function (descriptor, node, host, scope) {\n  this._directives.push(new Directive(descriptor, this, node, host, scope));\n};\n\nVue.prototype._compile = function (el) {\n  var options = this.$options;\n  var original = el;\n  // el = transclude(el)\n  // 源码里使用了一个叫做 transclude 的方法来做了很多兼容处理,非常复杂\n  if (options.template) {\n    el = stringToFragment(options.template);\n  } else {\n    el = nodeToFragment(el);\n  }\n\n  var linkFn = compile(el);\n  var unlinkFn = linkFn(this, el);\n\n  replace$1(original, el);\n};\n\nVue.prototype.$mount = function (el) {\n  el = document.querySelector(el);\n\n  this._compile(el);\n};\n\nreturn Vue;\n\n})));"]}