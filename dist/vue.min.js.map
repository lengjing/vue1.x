{"version":3,"sources":["vue.js"],"names":["global","factory","exports","module","define","amd","Vue","this","parseText","text","tagRE","test","match","index","value","tokens","lastIndex","exec","push","slice","tag","trim","length","peek","str","charCodeAt","next","eof","len","eatSpace","spaceChr","isStringStart","chr","doubleChr","singleChr","isExpStart","expStartChr","isExpEnd","start","expChrPair","parseString","stringQuote","escapeChr","parseSpecialExp","inExp","startChr","parseExpression","pipeChr","state","startState","filterArgState","filterState","filterNameState","parseDirective","s","dir","expression","replace$1","target","el","parent","parentNode","replaceChild","before$1","insertBefore","extend","to","from","i","def","obj","key","val","enumerable","Object","defineProperty","writable","configurable","isFunction","func","Dep","id","uid$1","subs","Observer","dep","Array","isArray","observeArray","walk","observe","vm","ob","addVm","defineReactive","property","getOwnPropertyDescriptor","getter","get","setter","set","childOb","call","depend","e","l","__ob__","newVal","notify","compile","nodeLinkFn","compileNode","childLinkFn","hasChildNodes","compileNodeList","childNodes","host","scope","frag","linkAndCapture","linker","originalDirCount","_directives","dirs","_bind","node","type","nodeType","compileElement","compileTextNode","nodeList","linkFns","terminal","nodes","childrenLinkFn","n","linkFn","hasAttrs","hasAttributes","attrs","attributes","checkTerminalDirectives","compileDirectives","attr","name","matched","dirName","rawName","termDef","j","dirAttrRE","publicDirectives","parsed","descriptor","raw","fn","_bindDir","wholeText","token","document","createDocumentFragment","processTextToken","createTextNode","appendChild","fragClone","cloneNode","rawValue","dirDef","parseExpression$1","exp","makeGetterFn","body","Function","Math","Watcher","expOrFn","cb","options","isFn","_watchers","uid$2","active","deps","newDeps","depIds","Set","newDepIds","undefined","res","lazy","Directive","_host","_scope","_frag","stringToFragment","templateString","div","createElement","innerHTML","child","firstChild","nodeToFragment","nodeClone","_init","91","123","40","bind","update","html","anchor","replace","swap","remove","parseTemplate","createComment","before","prototype","addSub","sub","removeSub","$remove","addDep","keys","convert","items","vms","createAnchor","uid","vFor","inMatch","itMatch","iterator","alias","end","data","item","empty","create","parentScope","$parent","$forContext","docFrag","template","forId","nextSibling","removeChild","for","console","log","has","add","oldValue","removeAttribute","_bound","_update","oldVal","watcher","_watcher","$options","_initData","$mount","dataFn","_data","_proxy","self","_compile","original","querySelector"],"mappings":"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","file":"vue.min.js","sourcesContent":["/*!\n * Vue.js v1.0.28-csp\n * (c) 2018 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Vue = factory());\n}(this, (function () { 'use strict';\n\nvar tagRE = /{{((?:.|\\n)+?)}}/g;\n\n/**\n * 解析文本\n * eg: aaa{{var}}bbb => [{value: 'aaa'}, {value: 'var', tag: true}, {value: 'bbb'}]\n * @param {String} text\n */\n\nfunction parseText(text) {\n  if (!tagRE.test(text)) {\n    return null;\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, value;\n  while (match = tagRE.exec(text)) {\n    index = match.index;\n    value = match[1];\n    if (index > lastIndex) {\n      tokens.push({\n        value: text.slice(lastIndex, index)\n      });\n    }\n\n    tokens.push({\n      tag: true,\n      value: value.trim()\n    });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push({\n      value: text.slice(lastIndex)\n    });\n  }\n  return tokens;\n}\n\nvar str;\nvar dir;\nvar len;\nvar index;\nvar chr;\nvar state;\nvar startState = 0;\nvar filterState = 1;\nvar filterNameState = 2;\nvar filterArgState = 3;\n\nvar doubleChr = 0x22;\nvar singleChr = 0x27;\nvar pipeChr = 0x7C;\nvar escapeChr = 0x5C;\nvar spaceChr = 0x20;\n\nvar expStartChr = { 0x5B: 1, 0x7B: 1, 0x28: 1 };\nvar expChrPair = { 0x5B: 0x5D, 0x7B: 0x7D, 0x28: 0x29 };\n\nfunction peek() {\n  return str.charCodeAt(index + 1);\n}\n\nfunction next() {\n  return str.charCodeAt(++index);\n}\n\nfunction eof() {\n  return index >= len;\n}\n\nfunction eatSpace() {\n  while (peek() === spaceChr) {\n    next();\n  }\n}\n\nfunction isStringStart(chr) {\n  return chr === doubleChr || chr === singleChr;\n}\n\nfunction isExpStart(chr) {\n  return expStartChr[chr];\n}\n\nfunction isExpEnd(start, chr) {\n  return expChrPair[start] === chr;\n}\n\nfunction parseString() {\n  var stringQuote = next();\n  var chr;\n  while (!eof()) {\n    chr = next();\n    // escape char\n    if (chr === escapeChr) {\n      next();\n    } else if (chr === stringQuote) {\n      break;\n    }\n  }\n}\n\nfunction parseSpecialExp(chr) {\n  var inExp = 0;\n  var startChr = chr;\n\n  while (!eof()) {\n    chr = peek();\n    if (isStringStart(chr)) {\n      parseString();\n      continue;\n    }\n\n    if (startChr === chr) {\n      inExp++;\n    }\n    if (isExpEnd(startChr, chr)) {\n      inExp--;\n    }\n\n    next();\n\n    if (inExp === 0) {\n      break;\n    }\n  }\n}\n\n/**\n * syntax:\n * expression | filterName  [arg  arg [| filterName arg arg]]\n */\n\nfunction parseExpression() {\n  var start = index;\n  while (!eof()) {\n    chr = peek();\n    if (isStringStart(chr)) {\n      parseString();\n    } else if (isExpStart(chr)) {\n      parseSpecialExp(chr);\n    } else if (chr === pipeChr) {\n      next();\n      chr = peek();\n      if (chr === pipeChr) {\n        next();\n      } else {\n        if (state === startState || state === filterArgState) {\n          state = filterState;\n        }\n        break;\n      }\n    } else if (chr === spaceChr && (state === filterNameState || state === filterArgState)) {\n      eatSpace();\n      break;\n    } else {\n      if (state === filterState) {\n        state = filterNameState;\n      }\n      next();\n    }\n  }\n\n  return str.slice(start + 1, index) || null;\n}\n\nfunction parseDirective(s) {\n  // reset parser state\n  str = s;\n  dir = {};\n  len = str.length;\n  index = -1;\n  chr = '';\n  state = startState;\n\n  var filters;\n\n  dir.expression = parseExpression().trim();\n\n  return dir;\n}\n\nfunction replace$1(target, el) {\n  var parent = target.parentNode;\n  if (parent) {\n    parent.replaceChild(el, target);\n  }\n}\n\nfunction before$1(el, target) {\n  target.parentNode.insertBefore(el, target);\n}\n\nfunction extend(to, from) {\n  for (var i in from) {\n    to[i] = from[i];\n  }\n}\n\nfunction def(obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\nfunction isFunction(func) {\n  return typeof func === 'function';\n}\n\nvar text = {\n  bind: function bind() {\n    this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\n  },\n\n  update: function update(value) {\n    this.el[this.attr] = value;\n  }\n};\n\nvar html = {\n\n  bind: function bind() {\n    // a comment node means this is a binding for\n    // {{{ inline unescaped html }}}\n    if (this.el.nodeType === 8) {\n      // hold nodes\n      this.nodes = [];\n      // replace the placeholder with proper anchor\n      this.anchor = document.createTextNode('v-html');\n      replace(this.el, this.anchor);\n    }\n  },\n\n  update: function update(value) {\n    if (this.nodes) {\n      this.swap(value);\n    } else {\n      this.el.innerHTML = value;\n    }\n  },\n\n  swap: function swap(value) {\n    // remove old nodes\n    var i = this.nodes.length;\n    while (i--) {\n      remove(this.nodes[i]);\n    }\n    // convert new value to a fragment\n    // do not attempt to retrieve from id selector\n    var frag = value ? parseTemplate(value) : document.createComment('');\n    // save a reference to these nodes so we can remove later\n    this.nodes = frag.childNodes;\n    before(frag, this.anchor);\n  }\n};\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * 每个 dep 实例都是一个可观测对象，可被多个指令订阅\n *\n *\n */\nfunction Dep() {\n  this.id = uid$1++;\n  this.subs = [];\n}\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\nDep.prototype.addSub = function (sub) {\n  this.subs.push(sub);\n};\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\nDep.prototype.removeSub = function (sub) {\n  this.subs.$remove(sub);\n};\n\n/**\n * Add self as a dependency to the target watcher.\n */\nDep.prototype.depend = function () {\n  Dep.target.addDep(this);\n};\n\n/**\n * Notify all subscribers of a new value.\n */\nDep.prototype.notify = function () {\n  // stablize the subscriber list first\n  var subs = this.subs;\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @constructor\n */\n\nfunction Observer(value) {\n  this.value = value;\n  this.dep = new Dep();\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n}\n\n// Instance methods\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n *\n * @param {Object} obj\n */\n\nObserver.prototype.walk = function (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    this.convert(keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\nObserver.prototype.observeArray = function (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\nObserver.prototype.convert = function (key, val) {\n  defineReactive(this.value, key, val);\n};\n\n/**\n * Add an owner vm, so that when $set/$delete mutations\n * happen we can notify owner vms to proxy the keys and\n * digest the watchers. This is only called when the object\n * is observed as an instance's root $data.\n *\n * @param {Vue} vm\n */\n\nObserver.prototype.addVm = function (vm) {\n  (this.vms || (this.vms = [])).push(vm);\n};\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @param {Vue} [vm]\n * @return {Observer|undefined}\n * @static\n */\n\nfunction observe(value, vm) {\n  if (!value || typeof value !== 'object') {\n    return;\n  }\n  var ob = new Observer(value);\n  if (ob && vm) {\n    ob.addVm(vm);\n  }\n  return ob;\n}\n\n/**\n * Define a reactive property on an Object.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\n\nfunction defineReactive(obj, key, val) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return;\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter() {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          for (var e, i = 0, l = value.length; i < l; i++) {\n            e = value[i];\n            e && e.__ob__ && e.__ob__.dep.depend();\n          }\n        }\n      }\n      return value;\n    },\n    set: function reactiveSetter(newVal) {\n      var value = getter ? getter.call(obj) : val;\n      if (newVal === value) {\n        return;\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\nvar createAnchor = function createAnchor(anchor) {\n  return document.createComment(anchor);\n};\n\nvar uid = 0;\n\n// 源码里 for 指令写的特别特别复杂\n\nvar vFor = {\n\n  terminal: true,\n\n  bind: function bind() {\n    // support \"item in/of items\" syntax\n    var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);\n    if (inMatch) {\n      var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\n      if (itMatch) {\n        this.iterator = itMatch[1].trim();\n        this.alias = itMatch[2].trim();\n      } else {\n        this.alias = inMatch[1].trim();\n      }\n      this.expression = inMatch[2];\n    }\n\n    // uid as a cache identifier\n    this.id = '__v-for__' + ++uid;\n\n    // 添加锚点\n    this.start = createAnchor('v-for-start');\n    this.end = createAnchor('v-for-end');\n\n    replace$1(this.el, this.end);\n    before$1(this.start, this.end);\n\n    // 先不缓存了，简单点\n    // this.cache = Object.create(null)\n  },\n\n  update: function update(data) {\n    var item = data[0];\n    var alias = this.alias;\n    var start = this.start;\n    var end = this.end;\n    // var inDocument = inDoc(start)\n    var i, l, frag, key, value;\n\n    // 每次 update 的时候都先清除下 frag，很粗暴的做法\n    this.empty();\n\n    for (i = 0, l = data.length; i < l; i++) {\n      item = data[i];\n      key = null;\n      value = item;\n      frag = this.create(value, alias, i, key);\n\n      before$1(frag, end);\n    }\n  },\n  /**\n   * Create a new fragment instance.\n   *\n   * @param {*} value\n   * @param {String} alias\n   * @param {Number} index\n   * @param {String} [key]\n   * @return {Fragment}\n   */\n  create: function create(value, alias, index, key) {\n    var host = this._host;\n    // create iteration scope\n    var parentScope = this._scope || this.vm;\n    var scope = Object.create(parentScope);\n    // ref holder for the scope\n    // scope.$refs = Object.create(parentScope.$refs)\n    // scope.$els = Object.create(parentScope.$els)\n    // make sure point $parent to parent scope\n    scope.$parent = parentScope;\n    // for two-way binding on alias\n    scope.$forContext = this;\n    // define scope properties\n    // important: define the scope alias without forced conversion\n    // so that frozen data structures remain non-reactive.\n    defineReactive(scope, alias, value);\n\n    // 创建一个 frag 让他单独和自己的 scope 去 link\n    var docFrag = document.createDocumentFragment();\n    docFrag.appendChild(this.el);\n    var template = docFrag.cloneNode(true).firstChild;\n    var linker = compile(this.el);\n    var unlink = linker(this.vm, template, null, scope);\n    var frag = template;\n\n    frag.forId = this.id;\n\n    return frag;\n  },\n\n  // 清除锚点间的节点\n  empty: function empty() {\n    var start = this.start;\n    var end = this.end;\n    while (start.nextSibling && start.nextSibling !== end) {\n      this.remove(start.nextSibling);\n    }\n  },\n  remove: function remove(node) {\n    if (node && node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  }\n};\n\nvar publicDirectives = {\n  text: text,\n  html: html,\n  'for': vFor\n};\n\nvar dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;\n\n/**\n * Compile a template and return a reusable composite link\n * function, which recursively contains more link functions\n * inside. This top level compile function would normally\n * be called on instance root nodes, but can also be used\n * for partial compilation if the partial argument is true.\n *\n * The returned composite link function, when called, will\n * return an unlink function that tearsdown all directives\n * created during the linking phase.\n *\n * 编译一段模板并返回一个可以重复使用的 link 方法，\n * 这个 link 方法（compositeLinkFn）的内部闭包了很多 link 方法，它们都是通过迭代遍历的方式编译而来。\n * 在整个编译过程中最主要的就是指令的编译，当 compositeLinkFn 方法被调用的时候，\n * 每个被闭包的 link 方法会分别被执行生成一个个指令挂载到 vm 实例上（_dirtives属性里）\n * 与此同时指令的 _bind 方法也会被执行，这个 _bind 方法可以理解成“绑定指令”，相当于指令初始化。\n * 每个指令实例的内部都会包含一个 watcher 实例，用来 “watch” 依赖（dep）,\n * 当依赖变动的时候可以通知 watcher 去更新。\n *\n * @param {Element|DocumentFragment} el\n */\nfunction compile(el) {\n  var nodeLinkFn = compileNode(el);\n  var childLinkFn = el.hasChildNodes ? compileNodeList(el.childNodes) : null;\n\n  return function compositeLinkFn(vm, el, host, scope, frag) {\n    // link\n    var dirs = linkAndCapture(function compositeLinkCapturer() {\n      if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\n      if (childLinkFn) childLinkFn(vm, el.childNodes, host, scope, frag);\n    }, vm);\n    // :todo\n    return function unlinkFn() {};\n  };\n}\n\n/**\n * Apply a linker to a vm/element pair and capture the\n * directives created during the process.\n *\n * @param {Function} linker\n * @param {Vue} vm\n */\nfunction linkAndCapture(linker, vm) {\n  var originalDirCount = vm._directives.length;\n  linker();\n  // 在有终端指令的情况下会出现多次编译，这个时候需要过滤掉已经初始化过的指令\n  var dirs = vm._directives.slice(originalDirCount);\n  for (var i = 0; i < dirs.length; i++) {\n    dirs[i]._bind();\n  }\n}\n\n/**\n * 编译单个节点\n * @param {Node} node\n * @return {Function|null}\n */\nfunction compileNode(node) {\n  var type = node.nodeType;\n  if (type === 1) {\n    return compileElement(node);\n  } else if (type === 3) {\n    // 其实纯文本节点可以看成一个语法糖\n    // <div>{{foo}}</div> === <div v-text=\"foo\" />\n    return compileTextNode(node);\n  } else {\n    return null;\n  }\n}\n\n/**\n * 编译节点列表\n * @param {NodeList} nodeList\n */\nfunction compileNodeList(nodeList) {\n  var linkFns = [];\n  var nodeLinkFn, childLinkFn, node;\n  for (var i = 0; i < nodeList.length; i++) {\n    node = nodeList[i];\n    nodeLinkFn = compileNode(node);\n    childLinkFn = node.hasChildNodes &&\n    // 如果是终端指令的节点那么内部的子节点都由它自己编译\n    // 因为子节点内的指令有可能依赖于终端指令\n    // 比如 <li v-for=\"item in list\"> <a>{{item}}</a> </li>\n    // a 标签内的 text 指令{{item}}中变量 item 是由 v-for 指令提供的\n    // 所以需要由 v-for 指令自己去编译\n    !(nodeLinkFn && nodeLinkFn.terminal) ? compileNodeList(node.childNodes) : null;\n    // 成对存放\n    linkFns.push(nodeLinkFn, childLinkFn);\n  }\n\n  return function childLinkFn(vm, nodes, host, scope, frag) {\n    var node, nodeLinkFn, childrenLinkFn;\n    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n      node = nodes[n];\n      // 成对取值\n      nodeLinkFn = linkFns[i++];\n      childrenLinkFn = linkFns[i++];\n      var childNodes = node.childNodes;\n      if (nodeLinkFn) {\n        nodeLinkFn(vm, node, host, scope, frag);\n      }\n      if (childrenLinkFn) {\n        childrenLinkFn(vm, childNodes, host, scope, frag);\n      }\n    }\n  };\n}\n\n/**\n * 编译元素\n * @param {Element} el\n */\nfunction compileElement(el) {\n  var linkFn;\n  var hasAttrs = el.hasAttributes();\n  var attrs = hasAttrs && el.attributes;\n  // 检查是否包含终端指令（for 或者 if）\n  if (hasAttrs) {\n    linkFn = checkTerminalDirectives(el, attrs);\n  }\n  // 检查元素指令 eg: <v-if></v-if>\n  // if (!linkFn) {\n  // linkFn = checkElementDirectives(el, options)\n  // }\n  // 检查自定义 component eg: <my-component />\n  // if (!linkFn) {\n  // linkFn = checkComponent(el, options)\n  // }\n  // 常规指令\n  if (!linkFn && hasAttrs) {\n    linkFn = compileDirectives(attrs);\n  }\n  return linkFn;\n}\n\n/**\n * 检查终端指令\n * @param {Element} el\n * @param {Array} attrs\n */\nfunction checkTerminalDirectives(el, attrs) {\n  var attr, name, value, matched, dirName, rawName, def, termDef;\n  for (var i = 0, j = attrs.length; i < j; i++) {\n    attr = attrs[i];\n    name = attr.name;\n    if (matched = name.match(dirAttrRE)) {\n      def = publicDirectives[matched[1]];\n      if (def && def.terminal) {\n        if (!termDef) {\n          termDef = def;\n          rawName = attr.name;\n          value = attr.value;\n          dirName = matched[1];\n        }\n      }\n    }\n  }\n\n  if (termDef) {\n    var parsed = parseDirective(value);\n    var descriptor = {\n      name: dirName,\n      expression: parsed.expression,\n      raw: value,\n      attr: rawName,\n      def: termDef\n    };\n\n    var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\n      vm._bindDir(descriptor, el, host, scope, frag);\n    };\n    fn.terminal = true;\n    return fn;\n  }\n}\n\n/**\n * 编译文本节点\n * @param {Node} node\n */\nfunction compileTextNode(node) {\n  var tokens = parseText(node.wholeText);\n  if (!tokens) {\n    return null;\n  }\n\n  var frag = document.createDocumentFragment();\n  var el, token;\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    el = token.tag ? processTextToken(token) : document.createTextNode(token.value);\n    frag.appendChild(el);\n  }\n\n  return function textNodeLinkFn(vm, el, host, scope) {\n    var fragClone = frag.cloneNode(true);\n    var childNodes = fragClone.childNodes;\n    var token, value, node;\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      token = tokens[i];\n      value = token.value;\n      if (token.tag) {\n        node = childNodes[i];\n        vm._bindDir(token.descriptor, node, host, scope);\n      }\n    }\n    replace$1(el, fragClone);\n  };\n}\n\n/**\n * 编译指令集\n * @param {Array} attrs\n */\nfunction compileDirectives(attrs) {\n  var i = attrs.length;\n  var dirs = [];\n  var attr, name, value, rawName, rawValue, dirName, dirDef, matched;\n  while (i--) {\n    attr = attrs[i];\n    name = rawName = attr.name;\n    value = rawValue = attr.value;\n\n    //\n    if (matched = name.match(dirAttrRE)) {\n      dirName = matched[1];\n\n      // 应该要在 vm 实例中查找的，因为有可能存在自定义指令的情况\n      // 所以这里的做法是欠妥的\n      dirDef = publicDirectives[dirName];\n      pushDir(dirName, dirDef);\n    }\n  }\n\n  /**\n   * Push a directive.\n   *\n   * @param {String} dirName\n   * @param {Object|Function} def\n   * @param {Array} [interpTokens]\n   */\n\n  function pushDir(dirName, def) {\n    var parsed = parseDirective(value);\n    dirs.push({\n      name: dirName,\n      attr: rawName,\n      raw: rawValue,\n      def: def,\n      expression: parsed && parsed.expression\n    });\n  }\n\n  if (dirs.length) {\n    return function nodeLinkFn(vm, el, host, scope, frag) {\n      var i = dirs.length;\n      while (i--) {\n        vm._bindDir(dirs[i], el, host, scope, frag);\n      }\n    };\n  }\n}\n/**\n * 处理文本 token\n * @param {String} token\n */\nfunction processTextToken(token) {\n  var el = document.createTextNode('');\n  var parsed = parseDirective(token.value);\n  var type = 'text';\n\n  token.descriptor = {\n    name: type,\n    def: publicDirectives[type],\n    expression: parsed.expression\n  };\n\n  return el;\n}\n\nfunction parseExpression$1(exp) {\n  return {\n    get: makeGetterFn('scope.' + exp),\n    set: function set() {}\n  };\n}\n\nfunction makeGetterFn(body) {\n  var fn = new Function('scope', 'Math', 'return ' + body);\n  return function (scope) {\n    return fn.call(this, scope, Math);\n  };\n}\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n *\n * @param {*} vm\n * @param {*} expOrFn\n * @param {*} cb\n * @param {*} options\n */\nfunction Watcher(vm, expOrFn, cb, options) {\n  if (options) {\n    extend(this, options);\n  }\n  var isFn = typeof expOrFn === 'function';\n  this.vm = vm;\n  vm._watchers.push(this);\n  this.expression = expOrFn;\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new Set();\n  this.newDepIds = new Set();\n\n  // parse expression for getter/setter\n  if (isFn) {\n    this.getter = expOrFn;\n    this.setter = undefined;\n  } else {\n    var res = parseExpression$1(expOrFn);\n    this.getter = res.get;\n    this.setter = res.set;\n  }\n  this.value = this.lazy ? undefined : this.get();\n}\n\nWatcher.prototype.get = function () {\n  Dep.target = this;\n\n  var scope = this.scope || this.vm;\n  var value;\n  try {\n    value = this.getter.call(scope, scope);\n  } catch (e) {\n    console.log(e);\n  }\n  return value;\n};\n\nWatcher.prototype.addDep = function (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\nWatcher.prototype.update = function () {\n  var value = this.get();\n  if (value !== this.value) {\n    // set new value\n    var oldValue = this.value;\n    this.value = value;\n    this.cb.call(this.vm, value, oldValue);\n  }\n};\n\n/**\n * 指令类\n * @param {*} descriptor\n * @param {*} vm\n * @param {*} el\n * @param {*} host\n * @param {*} scope\n * @param {*} frag\n */\nfunction Directive(descriptor, vm, el, host, scope, frag) {\n  this.vm = vm;\n  this.el = el;\n  this.descriptor = descriptor;\n  this.name = descriptor.name;\n  this.expression = descriptor.expression;\n  // private\n  // this._locked = false\n  // this._bound = false\n  // this._listeners = null\n  // link context\n  this._host = host;\n  this._scope = scope;\n  this._frag = frag;\n}\n\nDirective.prototype._bind = function () {\n  var name = this.name;\n  var descriptor = this.descriptor;\n\n  // 移除属性\n  // 编译过的节点需要移除指令属性防止被再次编译\n  if (this.el && this.el.removeAttribute) {\n    var attr = descriptor.attr || 'v-' + name;\n    this.el.removeAttribute(attr);\n  }\n\n  // 复制 def 属性\n  var def = descriptor.def;\n  if (typeof def === 'function') {\n    this.update = def;\n  } else {\n    extend(this, def);\n  }\n\n  // 初始化 bind\n  if (this.bind) {\n    this.bind();\n  }\n  this._bound = true;\n\n  if (this.expression && this.update) {\n    var dir = this;\n    // 这里套了一层 function 目的是为了让 update 方法内的 this 指向正对的对象\n    this._update = function (val, oldVal) {\n      dir.update(val, oldVal);\n    };\n\n    var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\n    {\n      scope: this._scope\n    });\n    // v-model with inital inline value need to sync back to\n    // model instead of update to DOM on init. They would\n    // set the afterBind hook to indicate that.\n    // if (this.afterBind) {\n    //   this.afterBind()\n    // } else if (this.update) {\n    //   this.update(watcher.value)\n    // }\n    if (this.update) {\n      this.update(watcher.value);\n    }\n  }\n};\n\nfunction stringToFragment(templateString) {\n  var frag = document.createDocumentFragment();\n  var div = document.createElement('div');\n\n  div.innerHTML = templateString;\n\n  var child;\n  while (child = div.firstChild) {\n    frag.appendChild(child);\n  }\n\n  return frag;\n}\n\nfunction nodeToFragment(node) {\n  var nodeClone = node.cloneNode(true);\n  var frag = document.createDocumentFragment();\n\n  var child;\n  while (child = nodeClone.firstChild) {\n    frag.appendChild(child);\n  }\n\n  return frag;\n}\n\nfunction Vue(options) {\n  this._init(options);\n}\n\nVue.prototype._init = function (options) {\n  this.$options = options || {};\n\n  this._directives = [];\n  this._watchers = [];\n\n  this._initData();\n\n  if (options.el) {\n    // 程序编译的入口\n    this.$mount(options.el);\n  }\n};\n\n/**\n * 初始化 data\n */\nVue.prototype._initData = function () {\n  var dataFn = this.$options.data;\n  // 官方文档建议使用 function 的形式\n  var data = this._data = isFunction(dataFn) ? dataFn() : dataFn;\n  var keys = Object.keys(data);\n  var i, key;\n  i = keys.length;\n  while (i--) {\n    key = keys[i];\n    // 把 data 属性下的 key 代理到 vm 实例上\n    this._proxy(key);\n  }\n  // observable 化 data\n  // 目的为了让 data 在取值/赋值的时候可被监听\n  // 从而实现响应式的效果\n  observe(data, this);\n};\n\nVue.prototype._proxy = function (key) {\n  var self = this;\n  Object.defineProperty(self, key, {\n    configurable: true,\n    enumerable: true,\n    get: function proxyGetter() {\n      return self._data[key];\n    },\n    set: function proxySetter(val) {\n      self._data[key] = val;\n    }\n  });\n};\n\nVue.prototype._bindDir = function (descriptor, node, host, scope) {\n  this._directives.push(new Directive(descriptor, this, node, host, scope));\n};\n\nVue.prototype._compile = function (el) {\n  var options = this.$options;\n  var original = el;\n  // el = transclude(el)\n  // 源码里使用了一个叫做 transclude 的方法来做了很多兼容处理,非常复杂\n  if (options.template) {\n    el = stringToFragment(options.template);\n  } else {\n    el = nodeToFragment(el);\n  }\n\n  var linkFn = compile(el);\n  var unlinkFn = linkFn(this, el);\n\n  replace$1(original, el);\n};\n\nVue.prototype.$mount = function (el) {\n  el = document.querySelector(el);\n\n  this._compile(el);\n};\n\nreturn Vue;\n\n})));"]}